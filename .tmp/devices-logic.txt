import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  fetchDevices,
  createDevice,
  updateDevice,
  testDeviceConnection,
  probeDeviceConnection,
  getAuthUser,
  fetchSchoolDevices,
  createSchoolDevice,
  updateSchoolDevice,
  deleteSchoolDevice,
  getWebhookInfo,
  BACKEND_URL,
  deleteDevice,
  cloneStudentsToDevice,
  cloneDeviceToDevice,
} from '../api';
import { useGlobalToast } from '../hooks/useToast';
import { useModalA11y } from '../hooks/useModalA11y';
import { Icons } from '../components/ui/Icons';
import type { DeviceConfig, SchoolDeviceInfo } from '../types';
import type { WebhookInfo } from '../api';
import {
  isDeviceCredentialsExpired,
  normalizeDeviceId,
  resolveLocalDeviceForBackend,
} from '../utils/deviceResolver';
import { appLogger } from '../utils/logger';

const DEFAULT_DEVICE_CREDENTIALS_LIMIT = 10;
const parsedDeviceLimit = Number(import.meta.env.VITE_DEVICE_CREDENTIALS_LIMIT);
const DEVICE_CREDENTIALS_LIMIT =
  Number.isFinite(parsedDeviceLimit) && parsedDeviceLimit > 0
    ? Math.floor(parsedDeviceLimit)
    : DEFAULT_DEVICE_CREDENTIALS_LIMIT;

export function DevicesPage() {
  const navigate = useNavigate();
  const [credentials, setCredentials] = useState<DeviceConfig[]>([]);
  const [editingBackendId, setEditingBackendId] = useState<string | null>(null);
  const [editingLocalId, setEditingLocalId] = useState<string | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isCredentialsModalOpen, setIsCredentialsModalOpen] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    host: '',
    location: '',
    port: 80,
    username: '',
    password: '',
    deviceType: 'ENTRANCE',
    deviceId: '',
  });
  const [loading, setLoading] = useState(false);
  const [testingId, setTestingId] = useState<string | null>(null);
  const [testStatus, setTestStatus] = useState<Record<string, 'ok' | 'fail'>>({});
  const [webhookInfo, setWebhookInfo] = useState<WebhookInfo | null>(null);
  const [webhookLoading, setWebhookLoading] = useState(false);
  const [showWebhookAdvanced, setShowWebhookAdvanced] = useState(false);
  const [backendDevices, setBackendDevices] = useState<SchoolDeviceInfo[]>([]);
  const [backendLoading, setBackendLoading] = useState(false);
  const [pendingDelete, setPendingDelete] = useState<SchoolDeviceInfo | null>(null);
  const [pendingClone, setPendingClone] = useState<SchoolDeviceInfo | null>(null);
  const [pendingDeviceClone, setPendingDeviceClone] = useState<SchoolDeviceInfo | null>(null);
  const [sourceCloneId, setSourceCloneId] = useState<string>('');
  const [cloneStatus, setCloneStatus] = useState<{
    running: boolean;
    processed: number;
    success: number;
    failed: number;
    skipped: number;
    errors: Array<{ studentId?: string; name?: string; reason?: string }>;
  } | null>(null);
  const [deviceCloneStatus, setDeviceCloneStatus] = useState<{
    running: boolean;
    processed: number;
    success: number;
    failed: number;
    skipped: number;
    errors: Array<{ employeeNo?: string; name?: string; reason?: string }>;
  } | null>(null);
  const { addToast } = useGlobalToast();
  const { dialogRef: modalDialogRef, onDialogKeyDown: onModalDialogKeyDown } = useModalA11y(
    isModalOpen,
    () => setIsModalOpen(false),
    loading,
  );
  const { dialogRef: credentialsDialogRef, onDialogKeyDown: onCredentialsDialogKeyDown } = useModalA11y(
    isCredentialsModalOpen,
    () => setIsCredentialsModalOpen(false),
    loading,
  );
  const { dialogRef: deleteDialogRef, onDialogKeyDown: onDeleteDialogKeyDown } = useModalA11y(
    Boolean(pendingDelete),
    () => setPendingDelete(null),
    loading,
  );
  const { dialogRef: cloneDialogRef, onDialogKeyDown: onCloneDialogKeyDown } = useModalA11y(
    Boolean(pendingClone),
    () => setPendingClone(null),
    cloneStatus?.running ?? false,
  );
  const { dialogRef: deviceCloneDialogRef, onDialogKeyDown: onDeviceCloneDialogKeyDown } = useModalA11y(
    Boolean(pendingDeviceClone),
    () => setPendingDeviceClone(null),
    deviceCloneStatus?.running ?? false,
  );

  useEffect(() => {
    loadCredentials();
    loadWebhookInfo();
    loadBackendDevices();
  }, []);

  const loadCredentials = async () => {
    try {
      const data = await fetchDevices();
      setCredentials(data);
    } catch (err: unknown) {
      appLogger.error('Failed to load local device credentials', err);
      addToast('Ulanish sozlamalarini yuklashda xato', 'error');
    }
  };

  const loadWebhookInfo = async () => {
    const user = getAuthUser();
    const schoolId = user?.schoolId;
    if (!schoolId) return;
    setWebhookLoading(true);
    try {
      const info = await getWebhookInfo(schoolId);
      setWebhookInfo(info);
    } catch (err: unknown) {
      appLogger.error('Failed to load webhook info', err);
      const message = err instanceof Error ? err.message : 'Webhook ma\'lumotlarini yuklashda xato';
      addToast(message, 'error');
    } finally {
      setWebhookLoading(false);
    }
  };

  const loadBackendDevices = async () => {
    const user = getAuthUser();
    const schoolId = user?.schoolId;
    if (!schoolId) return;
    setBackendLoading(true);
    try {
      const localCredentials =
        credentials.length > 0 ? credentials : await fetchDevices().catch(() => []);
      const data = await fetchSchoolDevices(schoolId);
      setBackendDevices(data);
      // Agar eski credentiallarda backendId yo'q bo'lsa, deviceId orqali bog'lab qo'yamiz
      if (localCredentials.length > 0) {
        const byDeviceId = new Map<string, DeviceConfig>();
        localCredentials.forEach((device) => {
          if (device.deviceId) {
            byDeviceId.set(normalizeDeviceId(device.deviceId), device);
          }
        });
        const toUpdate = data
          .map((backend) => {
            if (!backend.deviceId) return null;
            const match = byDeviceId.get(normalizeDeviceId(backend.deviceId));
            if (!match) return null;
            if (match.backendId === backend.id) return null;
            return { backend, match };
          })
          .filter(Boolean) as Array<{ backend: SchoolDeviceInfo; match: DeviceConfig }>;

        if (toUpdate.length > 0) {
          await Promise.all(
            toUpdate.map(({ backend, match }) =>
              updateDevice(match.id, {
                backendId: backend.id,
                host: match.host,
                port: match.port,
                username: match.username,
                password: match.password,
                deviceId: match.deviceId,
              }),
            ),
          );
          await loadCredentials();
        }
      }
    } catch (err: unknown) {
      appLogger.error('Failed to load backend devices', err);
      const message = err instanceof Error ? err.message : 'Qurilmalarni yuklashda xato';
      addToast(message, 'error');
    } finally {
      setBackendLoading(false);
    }
  };

  const getCredentialsForBackend = (device: SchoolDeviceInfo) => {
    return resolveLocalDeviceForBackend(device, credentials).localDevice || undefined;
  };

  const isCredentialsExpired = (device?: DeviceConfig | null) => {
    return isDeviceCredentialsExpired(device);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const isCredentialsOnlyMode = isCredentialsModalOpen && !isModalOpen;
      const trimmedName = formData.name.trim();
      const trimmedDeviceId = formData.deviceId.trim();
      const hostTrimmed = formData.host.trim();
      const usernameTrimmed = formData.username.trim();
      const passwordTrimmed = formData.password.trim();
      const credentialsProvided =
        hostTrimmed.length > 0 &&
        usernameTrimmed.length > 0 &&
        passwordTrimmed.length > 0;
      const anyCredentialField =
        hostTrimmed.length > 0 ||
        usernameTrimmed.length > 0 ||
        passwordTrimmed.length > 0;

      if (anyCredentialField && !credentialsProvided) {
        addToast('Ulanish uchun host, username va parolni to\'liq kiriting', 'error');
        return;
      }
      if (anyCredentialField && (!Number.isFinite(formData.port) || formData.port <= 0 || formData.port > 65535)) {
        addToast('Port 1-65535 oralig\'ida bo\'lishi kerak', 'error');
        return;
      }
      if (!isCredentialsOnlyMode && !trimmedName) {
        addToast('Qurilma nomi majburiy', 'error');
        return;
      }

      const user = getAuthUser();
      const schoolId = user?.schoolId;
      if (!schoolId) {
        addToast('Maktab topilmadi', 'error');
        return;
      }

      let backendDevice: SchoolDeviceInfo | null = null;
      if (isCredentialsOnlyMode) {
        backendDevice = backendDevices.find((item) => item.id === editingBackendId) || null;
        if (!backendDevice) {
          addToast('Qurilma topilmadi', 'error');
          return;
        }
      } else {
        if (editingBackendId) {
          backendDevice = await updateSchoolDevice(editingBackendId, {
            name: trimmedName,
            deviceId: trimmedDeviceId || undefined,
            type: formData.deviceType,
            location: formData.location.trim() || undefined,
          });
          addToast('Qurilma yangilandi', 'success');
        } else {
          let resolvedDeviceId = trimmedDeviceId;
          if (!resolvedDeviceId && credentialsProvided) {
            const probe = await probeDeviceConnection({
              host: hostTrimmed,
              port: formData.port,
              username: usernameTrimmed,
              password: passwordTrimmed,
            });
            if (!probe.ok) {
              addToast(probe.message || 'Qurilmaga ulanib bo\'lmadi', 'error');
              return;
            }
            if (!probe.deviceId) {
              addToast('Qurilmadan deviceId olinmadi, qo\'lda kiriting', 'error');
              return;
            }
            resolvedDeviceId = probe.deviceId.trim();
          }
          if (!resolvedDeviceId) {
            addToast('Device ID yoki ulanish ma\'lumotlarini kiriting', 'error');
            return;
          }
          backendDevice = await createSchoolDevice(schoolId, {
            name: trimmedName,
            deviceId: resolvedDeviceId,
            type: formData.deviceType,
            location: formData.location.trim() || undefined,
          });
          addToast('Qurilma qo\'shildi', 'success');
        }
        await loadBackendDevices();
      }
      const hostKey = hostTrimmed.toLowerCase();
      const usernameKey = usernameTrimmed.toLowerCase();

      const existingLocal =
        (editingLocalId ? credentials.find((item) => item.id === editingLocalId) : null) ||
        (backendDevice ? getCredentialsForBackend(backendDevice) : undefined) ||
        credentials.find((item) => {
          const sameBackend = backendDevice ? item.backendId === backendDevice.id : false;
          const unlinked = !item.backendId;
          const endpointMatch =
            hostKey.length > 0 &&
            usernameKey.length > 0 &&
            item.host.trim().toLowerCase() === hostKey &&
            item.port === formData.port &&
            item.username.trim().toLowerCase() === usernameKey;
          return (sameBackend || unlinked) && endpointMatch;
        });

      if (credentialsProvided && backendDevice) {
        let savedLocal: DeviceConfig | null = null;
        if (!existingLocal && credentials.length >= DEVICE_CREDENTIALS_LIMIT) {
          addToast(`Ulanish sozlamalari limiti (${DEVICE_CREDENTIALS_LIMIT} ta) to'ldi`, 'error');
        } else {
          const payload: Omit<DeviceConfig, 'id'> = {
            backendId: backendDevice.id,
            host: hostTrimmed,
            port: formData.port,
            username: usernameTrimmed,
            password: passwordTrimmed,
            deviceId: backendDevice.deviceId || trimmedDeviceId || undefined,
          };

          if (existingLocal) {
            savedLocal = await updateDevice(existingLocal.id, payload);
          } else {
            savedLocal = await createDevice(payload);
          }
          await loadCredentials();
          addToast('Ulanish sozlamalari saqlandi', 'success');

          // Avtomatik test + deviceId sync
          if (savedLocal) {
            try {
              const test = await testDeviceConnection(savedLocal.id);
              appLogger.debug('[Device Test] auto test result', {
                localId: savedLocal.id,
                backendId: backendDevice.id,
                deviceIdFromTest: test.deviceId,
                ok: test.ok,
              });
              if (test.ok && test.deviceId) {
                if (!backendDevice.deviceId || backendDevice.deviceId !== test.deviceId) {
                  await updateSchoolDevice(backendDevice.id, { deviceId: test.deviceId });
                }
                if (savedLocal.deviceId !== test.deviceId || savedLocal.backendId !== backendDevice.id) {
                  await updateDevice(savedLocal.id, {
                    backendId: backendDevice.id,
                    host: savedLocal.host,
                    port: savedLocal.port,
                    username: savedLocal.username,
                    password: savedLocal.password,
                    deviceId: test.deviceId,
                  });
                }
                await Promise.all([loadBackendDevices(), loadCredentials()]);
              } else {
                appLogger.warn('[Device Test] deviceId missing after test', {
                  ok: test.ok,
                  deviceId: test.deviceId,
                });
              }
            } catch (err: unknown) {
              appLogger.warn('Auto test/sync failed', err);
            }
          }
        }
      }

      setFormData({
        name: '',
        host: '',
        location: '',
        port: 80,
        username: '',
        password: '',
        deviceType: 'ENTRANCE',
        deviceId: '',
      });
      setEditingBackendId(null);
      setEditingLocalId(null);
      setIsModalOpen(false);
      setIsCredentialsModalOpen(false);
    } catch (error: unknown) {
      appLogger.error('Device submit failed', error);
      addToast('Xatolik yuz berdi', 'error');
    } finally {
      setLoading(false);
    }
  };

  const openEditModal = (device: SchoolDeviceInfo) => {
    const local = getCredentialsForBackend(device);
      setEditingBackendId(device.id);
      setEditingLocalId(local?.id || null);
      setIsModalOpen(true);
      setFormData({
        name: device.name,
        host: local?.host || '',
        location: device.location || '',
        port: local?.port || 80,
        username: local?.username || '',
        password: local?.password || '',
        deviceType: device.type || 'ENTRANCE',
        deviceId: device.deviceId || local?.deviceId || '',
      });
    };

  const openCredentialsModal = (device: SchoolDeviceInfo) => {
    const local = getCredentialsForBackend(device);
    setEditingBackendId(device.id);
    setEditingLocalId(local?.id || null);
    setIsCredentialsModalOpen(true);
    setFormData({
      name: device.name,
      host: local?.host || '',
      location: device.location || '',
      port: local?.port || 80,
      username: local?.username || '',
      password: local?.password || '',
      deviceType: device.type || 'ENTRANCE',
      deviceId: device.deviceId || local?.deviceId || '',
    });
  };

  const handleTestConnection = async (device: SchoolDeviceInfo) => {
    const local = getCredentialsForBackend(device);
    if (!local) {
      addToast('Ulanish sozlamalari topilmadi', 'error');
      return;
    }
    if (isCredentialsExpired(local)) {
      addToast('Ulanish sozlamalari muddati tugagan. Qayta kiriting.', 'error');
      return;
    }
    setTestingId(device.id);
    try {
      const result = await testDeviceConnection(local.id);
      const ok = result.ok;
      setTestStatus((prev) => ({ ...prev, [device.id]: ok ? 'ok' : 'fail' }));
      addToast(ok ? 'Ulanish muvaffaqiyatli' : 'Ulanish muvaffaqiyatsiz', ok ? 'success' : 'error');

      if (ok) {
        const updates: Partial<Pick<SchoolDeviceInfo, 'deviceId' | 'isActive' | 'lastSeenAt'>> = {
          isActive: true,
          lastSeenAt: new Date().toISOString(),
        };
        if (result.deviceId && result.deviceId !== device.deviceId) {
          updates.deviceId = result.deviceId;
        }
        try {
          await updateSchoolDevice(device.id, updates);
          await loadBackendDevices();
          await loadCredentials();
        } catch (err: unknown) {
          appLogger.warn('Backend sync after test failed', err);
        }
      }
    } catch (err) {
      setTestStatus((prev) => ({ ...prev, [device.id]: 'fail' }));
      const message = err instanceof Error ? err.message : String(err);
      addToast(message || 'Ulanishni tekshirishda xato', 'error');
    } finally {
      setTestingId(null);
    }
  };

  const handleDeleteDevice = async () => {
    if (!pendingDelete) return;
    setLoading(true);
    try {
      const local = getCredentialsForBackend(pendingDelete);
      if (local) {
        await deleteDevice(local.id);
      }
      await deleteSchoolDevice(pendingDelete.id);
      await Promise.all([loadBackendDevices(), loadCredentials()]);
      addToast("Qurilma o'chirildi", 'success');
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Qurilmani o\'chirishda xato';
      addToast(message, 'error');
    } finally {
      setLoading(false);
      setPendingDelete(null);
    }
  };

  const handleStartClone = async () => {
    if (!pendingClone) return;
    setCloneStatus({ running: true, processed: 0, success: 0, failed: 0, skipped: 0, errors: [] });
    try {
      const result = await cloneStudentsToDevice({
        backendDeviceId: pendingClone.id,
      });
      setCloneStatus({
        running: false,
        processed: result.processed,
        success: result.success,
        failed: result.failed,
        skipped: result.skipped,
        errors: result.errors || [],
      });
      addToast(
        `Clone yakunlandi: ${result.success} muvaffaqiyatli, ${result.failed} xato, ${result.skipped} o'tkazildi.`,
        result.failed > 0 ? 'error' : 'success',
      );
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Clone jarayonida xato';
      setCloneStatus((prev) => prev ? { ...prev, running: false } : null);
      addToast(message, 'error');
    }
  };

  const handleStartDeviceClone = async () => {
    if (!pendingDeviceClone || !sourceCloneId) return;
    const source = getCredentialsForBackend(
      backendDevices.find((d) => d.id === sourceCloneId) || ({} as SchoolDeviceInfo),
    );
    const target = getCredentialsForBackend(pendingDeviceClone);
    if (!source || !target) {
      addToast("Manba yoki maqsad qurilmaning local sozlamalari topilmadi", 'error');
      return;
    }
    setDeviceCloneStatus({ running: true, processed: 0, success: 0, failed: 0, skipped: 0, errors: [] });
    try {
      const result = await cloneDeviceToDevice({
        sourceDeviceId: source.id,
        targetDeviceId: target.id,
      });
      setDeviceCloneStatus({
        running: false,
        processed: result.processed,
        success: result.success,
        failed: result.failed,
        skipped: result.skipped,
        errors: result.errors || [],
      });
      addToast(
        `Clone yakunlandi: ${result.success} muvaffaqiyatli, ${result.failed} xato, ${result.skipped} o'tkazildi.`,
        result.failed > 0 ? 'error' : 'success',
      );
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Clone jarayonida xato';
      setDeviceCloneStatus((prev) => prev ? { ...prev, running: false } : null);
      addToast(message, 'error');
    }
  };

  const deviceLimitReached = credentials.length >= DEVICE_CREDENTIALS_LIMIT;
  const openCreateModal = () => {
    setEditingBackendId(null);
    setEditingLocalId(null);
    setFormData({ name: '', host: '', location: '', port: 80, username: '', password: '', deviceType: 'ENTRANCE', deviceId: '' });
    setIsModalOpen(true);
  };

  const isBackendOnline = (lastSeenAt?: string | null) => {
    if (!lastSeenAt) return false;
    const last = new Date(lastSeenAt).getTime();
    if (Number.isNaN(last)) return false;
    return Date.now() - last < 2 * 60 * 60 * 1000;
  };

  const formatWebhookUrl = (value?: string) => {
    if (!value) return '';
    if (value.startsWith('http://') || value.startsWith('https://')) {
      try {
        const url = new URL(value);
        return `${url.pathname}${url.search}`;
      } catch (error: unknown) {
        void error;
        return value;
      }
    }
    if (value.startsWith('/')) return value;
    return `/${value}`;
  };

  const getBackendPortLabel = () => {
    try {
      const url = new URL(BACKEND_URL);
      if (url.port) return url.port;
      return url.protocol === 'https:' ? '443' : '80';
    } catch (error: unknown) {
      void error;
      return '';
    }
  };

  const maskWebhookValue = (value: string, kind: 'url' | 'secret' | 'header') => {
    if (!value) return '';
    if (kind === 'url') {
      return value.replace(/secret=[^&]+/i, 'secret=***');
    }
    return '****************';
  };

  const copyToClipboard = async (value: string, label: string) => {
    try {
      await navigator.clipboard.writeText(value);
      addToast(`${label} nusxalandi`, 'success');
    } catch (error: unknown) {
      void error;
      addToast('Nusxalashda xato', 'error');
    }
  };

  return (
